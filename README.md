# RSABag
Explication du fonctionnement de RSA à l'aide d'un challenge.
**RSA**
```
N = 299414541696079057892313324025675176540717914391016340476887410756223595067
e = 65537
c = 4411661085097543909849318376631746681150427615454967763654513675784095561
```
## Solve
On doit factoriser ``N`` en trouvant les nombres premiers (large primes) qui composent la valeur.
Le tool msieve permet de faire ça avec la commande suivante: 
```py
./msieve -q 299414541696079057892313324025675176540717914391016340476887410756223595067

299414541696079057892313324025675176540717914391016340476887410756223595067
p38: 16635750863390806321005018553115635153
p38: 17998258338611020155099256716570289739
```
On a nos deux nombres premiers (large primes):
```py
p = 16635750863390806321005018553115635153, q = 17998258338611020155099256716570289739
```
Maintenant on calcule le ```PHI (Φ)``` de cette manière:
```py
>>> p = 16635750863390806321005018553115635153
>>> q = 17998258338611020155099256716570289739
>>> print((p - 1) * (q - 1))
299414541696079057892313324025675176506083905189014514000783135486537670176
```
Le PHI:
```py
PHI = 299414541696079057892313324025675176506083905189014514000783135486537670176
```
Maintenant on trouve **e⁻¹(mod PHI)** avec:
```py
>>> import libnum
>>> PHI = 299414541696079057892313324025675176506083905189014514000783135486537670176
>>> e = 65537
>>> print(libnum.invmod(e, PHI))
198685307594500543947370403719312567726216991207486644176267723258221107745
```
Clé de déchiffrement:
```py
d = 198685307594500543947370403719312567726216991207486644176267723258221107745
```
On a plus qu'à déchiffrer le cipher **Message = Cipherᵈ(mod N)**:
```py
>>> from Crypto.Util.number import long_to_bytes
>>> d = 198685307594500543947370403719312567726216991207486644176267723258221107745
>>> cipher = 4411661085097543909849318376631746681150427615454967763654513675784095561
>>> N = 299414541696079057892313324025675176540717914391016340476887410756223595067
>>> print(long_to_bytes(pow(cipher, d, N)))
b't0r0nt0_ch4ll{R54_34zY}'
```
